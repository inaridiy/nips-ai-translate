---
original: adf73efd532a625742e1e3c6051def49760b27bb9b584fae76b633f327e53428
---

NIP-89
======

推荐的应用程序处理器
------------------

`草案` `可选`

本NIP描述了`kind:31989`和`kind:31990`：一种发现可以处理未知事件类型的应用程序的方法。

## 理由

Nostr的可发现性和透明的事件交互是其最有趣/新颖的机制之一。
本NIP提供了一种简单的方法，使客户端能够发现处理特定类型事件的应用程序，以确保跨客户端和跨类型的交互顺畅。

### 涉及的各方

此工作流程涉及三个参与者：

* 处理特定事件类型的应用程序（请注意，应用程序不一定需要是一个独立的实体，它可以只是与用户A相同的公钥）
    * 发布`kind:31990`，详细说明应用程序应如何重定向到它
* 用户A，推荐处理特定事件类型的应用程序
    * 发布`kind:31989`
* 用户B，寻求处理特定事件类型的应用程序推荐
    * 查询`kind:31989`，并根据结果查询`kind:31990`

## 事件

### 推荐事件
```json
{
  "kind": 31989,
  "pubkey": <推荐者用户公钥>,
  "tags": [
    ["d", <支持的事件类型>],
    ["a", "31990:app1-pubkey:<d-identifier>", "wss://relay1", "ios"],
    ["a", "31990:app2-pubkey:<d-identifier>", "wss://relay2", "web"]
  ]
}
```

`kind:31989`中的`d`标签是此事件推荐的支持事件类型。

同一个`kind:31989`可以出现多个`a`标签。

标签的第二个值应该是中继提示。
标签的第三个值应该是此推荐可能适用的平台。

## 处理器信息
```json
{
  "kind": 31990,
  "pubkey": "<应用程序公钥>",
  "content": "<可选的kind:0样式元数据>",
  "tags": [
    ["d", <随机id>],
    ["k", <支持的事件类型>],
    ["web", "https://..../a/<bech32>", "nevent"],
    ["web", "https://..../p/<bech32>", "nprofile"],
    ["web", "https://..../e/<bech32>"],
    ["ios", ".../<bech32>"]
  ]
}
```

* `content`是一个可选的`元数据`类似的字符串化JSON对象，如NIP-01中所述。当创建`kind:31990`的公钥不是应用程序时，此内容很有用。如果`content`为空，应使用公钥的`kind:0`来显示应用程序信息（例如名称、图片、网站、LUD16等）
* `k`标签的值是此`kind:31990`支持的事件类型。
使用`k`标签（而不是在`d`标签中包含类型）提供：
    * 如果应用程序支持多个事件类型且它们的处理程序URL相同，则同一事件中可以存在多个`k`标签。
    * 同一公钥可以有多个事件，具有不同的应用程序来处理相同的事件类型。
* URL中的`bech32`必须由客户端替换为应由应用程序加载的NIP-19编码实体。

应用程序可能注册多个标签，遵循NIP-19命名法作为数组的第二个值。

数组中没有第二个值的标签应被视为任何未被其他标签处理的NIP-19实体的通用处理程序。

# 客户端标签
发布事件时，客户端可以包含一个`client`标签。标识发布注释的客户端。此标签是`名称`、`地址`（标识处理程序事件）和用于查找处理程序事件的中继`提示`的元组。这对用户的隐私有影响，因此客户端应允许用户选择不使用此标签。

```json
{
  "kind": 1,
  "tags": [
    ["client", "My Client", "31990:app1-pubkey:<d-identifier>", "wss://relay1"]
  ]
  ...
}
```

## 用户流程
使用非`kind:1`为中心的nostr应用的用户A可以选择宣布/推荐某个特定类型处理程序应用。

当用户B在以社交媒体为中心的nostr客户端中看到未知事件类型时，客户端将允许用户B与未知类型事件交互（例如点击它）。

客户端可能会查询用户和用户关注的处理程序。

## 示例

### 用户A推荐`kind:31337`处理程序
用户A可能是Zapstr（一个以`kind:31337`为中心的客户端，用于曲目）的用户。使用Zapstr，用户A发布了一个事件，推荐Zapstr作为`kind:31337`处理程序。

```json
{
  "kind": 31989,
  "tags": [
    ["d", "31337"],
    ["a", "31990:1743058db7078661b94aaf4286429d97ee5257d14a86d6bfa54cb0482b876fb0:abcd", <中继url>, "web"]
  ],
  ...
}
```

### 用户B与`kind:31337`处理程序交互
用户B可能在他们的时间线上看到一个引用`kind:31337`事件的事件（例如，一个标记了`kind:31337`的`kind:1`）。

用户B的客户端不知道如何处理`kind:31337`，可能会使用其`alt`标签（如NIP-31中所述）显示事件。当用户点击事件时，应用程序会查询此`kind`的处理程序：

```json
["REQ", <id>, { "kinds": [31989], "#d": ["31337"], "authors": [<用户>, <用户联系人列表>] }]
```

关注用户A的用户B看到了那个`kind:31989`事件，并获取了应用程序和处理程序信息的`a`标记事件。

用户B的客户端看到应用程序的`kind:31990`，其中包含将用户重定向到相关URL的信息，URL中的所需实体已被替换。

### 绕过`kind:31989`的替代查询
或者，用户可以选择直接查询事件类型的`kind:31990`。客户端应谨慎执行此操作，并使用防垃圾机制或查询高质量的受限中继，以避免将用户引导到恶意处理程序。

```json
["REQ", <id>, { "kinds": [31990], "#k": [<所需事件类型>], "authors": [...] }]
```