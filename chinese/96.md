---
original: 1f753724e3c574f362498d942757fd376661a8b791689ddccd4b9f5fb1ba7654
---

# NIP-96

## HTTP 文件存储集成

`草案` `可选`

## 介绍

本 NIP 定义了一个用于 HTTP 文件存储服务器的 REST API，旨在与 nostr 网络配合使用。
该 API 将使 nostr 用户能够上传文件，并在之后的 nostr 笔记中通过 URL 引用这些文件。

该规范不使用通过 WebSocket 的常规 nostr 事件来存储、请求或检索数据，因为为了简单起见，服务器
不需要了解任何关于 nostr 中继的信息。

## 服务器适配

希望被 nostr 用户访问的文件存储服务器应该通过在 `/.well-known/nostr/nip96.json` 路径提供一个包含 `api_url` 的 HTTPS 路由来选择加入：

```js
{
  // 必需
  // 文件上传和删除从此 URL 提供服务
  // 如果 "download_url" 字段不存在或为空字符串，下载也从此 URL 提供服务
  "api_url": "https://your-file-server.example/custom-api-path",
  // 可选
  // 如果不存在，下载将从 api_url 提供服务
  "download_url": "https://a-cdn.example/a-path",
  // 可选
  // 注意：此字段不适用于 HTTP 服务器。
  // 如果你是一个 nostr 中继，使用你的 /.well-known/nostr/nip96.json
  // 仅仅是为了重定向到其他人的 HTTP 文件存储服务器的 /.well-known/nostr/nip96.json，请使用此字段
  // 在这种情况下，"api_url" 字段必须是空字符串
  "delegated_to_url": "https://your-file-server.example",
  // 可选
  "supported_nips": [60],
  // 可选
  "tos_url": "https://your-file-server.example/terms-of-service",
  // 可选
  "content_types": ["image/jpeg", "video/webm", "audio/*"],
  // 可选
  "plans": {
    // "free" 是唯一标准化的计划键，
    // 客户端可以使用它的存在来了解服务器是否提供免费存储
    "free": {
      "name": "免费套餐",
      // 默认为 true
      // 所有计划都必须支持 NIP-98 上传
      // 但某些计划也可能允许不使用它的上传
      "is_nip98_required": true,
      "url": "https://...", // 计划的登陆页面（如果有）
      "max_byte_size": 10485760,
      // 范围（天）/ 0 表示无过期时间
      // [7, 0] 表示可能从 7 天到无限期保存，
      // [0, 0] 表示没有过期时间
      // 提前过期可能是由于低流量或任何其他因素
      "file_expiration": [14, 90],
      "media_transformations": {
        "image": [
          'resizing'
        ]
      }
    }
  }
}
```

### 中继提示

注意：此部分不适用于 HTTP 服务器。

nostr 中继可以通过添加一个 `/.well-known/nostr/nip96.json`，其中 "delegated_to_url" 字段
指向服务器托管其自己的 `/.well-known/nostr/nip96.json` 的 URL，来重定向到其他人的 HTTP 文件存储服务器。
在这种情况下，"api_url" 字段必须是空字符串，所有其他字段必须不存在。

如果 nostr 中继也是 HTTP 文件存储服务器，
它必须使用 "api_url" 字段。

### 支持的文件存储服务器列表

请参阅 https://github.com/aljazceru/awesome-nostr#nip-96-file-storage-servers。

## 认证

在指定的情况下，`客户端`必须添加一个 [NIP-98](98.md) `Authorization` 头（**可选**地将编码的 `payload` 标签设置为文件的 256 位 SHA-256 哈希的 base64 编码 - 而不是整个请求体的哈希）。

## 上传

`POST $api_url` 作为 `multipart/form-data`。

**需要认证**

表单字段列表：

- `file`：**必需** 要上传的文件
- `caption`：**推荐** 简短描述；
- `expiration`：UNIX 时间戳（秒）。空字符串表示文件应永久存储。服务器不必遵守此设置。
- `size`：文件字节大小。这只是一个服务器可以用来在文件大小超过服务器限制时提前拒绝的值。
- `alt`：**推荐** 为视力障碍用户提供的严格描述文本。
- `media_type`："avatar" 或 "banner"。告知服务器该文件将用作头像或横幅。如果不存在，服务器将将其解释为普通上传，不进行特殊处理。
- `content_type`：MIME 类型，如 "image/jpeg"。这只是一个服务器可以用来在不支持该 MIME 类型时提前拒绝的值。
- `no_transform`："true" 要求服务器不要转换文件并按原样提供上传的文件，可能会被拒绝。

其他自定义表单数据字段可能会根据特定`服务器`支持而使用。
`服务器`不需要存储`客户端`发送的任何元数据。

`服务器`可能不会遵守文件中嵌入的`文件名`，它可能会在内部仅存储 SHA-256 哈希值作为文件名，忽略额外的元数据。
哈希足以唯一标识一个文件，这就是为什么它将在`下载`和`删除`路由中使用。

`服务器`必须将用户的 `pubkey` 字符串链接为文件的所有者，以便稍后允许他们删除文件。

`no_transform` 可用于将文件复制到多个服务器以实现冗余，客户端可以使用[服务器列表](#选择服务器)来查找可能包含相同文件的替代服务器。在上传文件并请求 `no_transform` 时，客户端应检查响应中的哈希是否匹配，以检测文件是否被修改。

### 响应代码

- `200 OK`：文件上传存在，但上传成功（现有哈希）
- `201 Created`：文件上传成功（新哈希）
- `202 Accepted`：文件上传正在等待处理，请参阅[延迟处理](#延迟处理)部分
- `413 Payload Too Large`：文件大小超过限制
- `400 Bad Request`：表单数据无效或不受支持。
- `403 Forbidden`：用户不允许上传或上传的文件哈希与 `Authorization` 头 `payload` 标签中包含的哈希不匹配。
- `402 Payment Required`：服务器要求付款，**此流程未定义**。

上传响应是一个 JSON 对象，如下所示：

```js
{
  // 如果成功则为 "success"，如果失败则为 "error"
  status: "success",
  // 自由文本成功、失败或信息消息
  message: "上传成功。",
  // 可选。请参阅"延迟处理"部分
  processing_url: "...",
  // 这使用 NIP-94 事件格式，但不需要
  // 填写某些字段，如 "id"、"pubkey"、"created_at" 和 "sig"
  //
  // 这包含下载 URL（"url"），
  // 服务器转换前的原始文件哈希（"ox"）
  // 以及（可选）服务器希望提供的所有文件元数据
  //
  // 如果上传不成功，nip94_event 字段将不存在
  nip94_event: {
    // 必需的标签："url" 和 "ox"
    tags: [
      // 可以与 /.well-known/nostr/nip96.json 中的 "download_url" 字段相同
      // （如果 "download_url" 不存在或为空字符串，则使用 "api_url" 字段），附加原始文件哈希。
      //
      // 注意，我们在 `ox` 值后附加了 .png 文件扩展名
      // （这是可选的，但强烈建议添加扩展名，因为它将帮助 nostr 客户端
      // 使用正则表达式检测文件类型）
      //
      // 也可以是任何用于下载文件的 URL
      // （使用或不使用 /.well-known/nostr/nip96.json 的 "download_url" 前缀），
      // 例如用于负载均衡目的。
      ["url", "https://your-file-server.example/custom-api-path/719171db19525d9d08dd69cb716a18158a249b7b3b3ec4bbdec5698dca104b7b.png"],
      // 转换前原始文件的 SHA-256 哈希。
      // 服务器必须存储它，即使它代表原始文件，因为
      // 用户可能会尝试使用此值下载/删除转换后的文件
      ["ox", "719171db19525d9d08dd69cb716a18158a249b7b3b3ec4bbdec5698dca104b7b"],
      // 可选。服务器转换后保存文件的 SHA-256 哈希。
      // 服务器可以但不需要存储此值。
      ["x", "543244319525d9d08dd69cb716a18158a249b7b3b3ec4bbde5435543acb34443"],
      // 可选。建议用于帮助客户端在下载之前轻松了解文件类型。
      ["m", "image/png"]
      // 可选。建议用于帮助客户端在下载文件之前为显示文件预留适当的 UI 空间。
      ["dim", "800x600"]
      // ... 其他可选的 NIP-94 标签
    ],
    content: ""
  },
  // ... 其他自定义字段（请考虑将它们添加到此 NIP 或 NIP-94 标签中）
}
```

请注意，如果服务器没有对接收到的文件应用任何转换，`nip94_event.tags.*.ox` 和 `nip94_event.tags.*.x` 字段将具有相同的值。服务器必须将保存的文件链接到任何服务器转换之前的**原始**文件的 SHA-256 哈希（`nip94_event.tags.*.ox` 标签值）。在下载或删除文件时，将使用**原始**文件的 SHA-256 哈希来标识保存的文件。

`客户端`可以将同一文件上传到一个或多个`服务器`。
上传成功后，`客户端`可以选择生成一个 [NIP-94](94.md) 事件，并通过包含缺失的字段将其发送到任何一组 nostr `中继`。

或者，`客户端`可以不使用 NIP-94，而是直接在 nostr 笔记中共享或嵌入上述 URL。

`客户端`还可以使用 `nip94_event` 中的标签来构造 `imeta` 标签

### 延迟处理

有时，服务器可能希望将上传的文件放入处理队列中进行延迟文件处理。

在这种情况下，服务器必须在处理未完成时提供原始文件，然后在处理完成后将原始文件替换为处理后的文件。上传响应与通常相同，但某些可选元数据（如 `nip94_event.tags.*.x` 和 `nip94_event.tags.*.size`）将不可用。

应在响应中返回预期的已知结果元数据。
例如，如果文件处理会将文件从 "jpg" 更改为 "webp"，
在 `nip94_event.tags.*.url` 字段值中使用 ".webp" 扩展名，并将 "image/webp" 设置为 `nip94_event.tags.*.m` 字段。
如果在处理结束前某些元数据未知，则在响应中省略它们。

上传响应可能包括一个 `processing_url` 字段，告知客户端可以用来检查文件处理是否完成的临时 URL。

如果处理尚未完成，服务器应在 `processing_url` URL 上回复 **200 OK** 状态和以下 JSON：

```
{
  // 应为 "processing"。如果为 "error"，则表示处理失败。
  status: "processing",
  message: "正在处理。请稍后再次检查更新状态。",
  percentage: 15 // 处理百分比。0 到 100 之间的整数。
}
```

当处理完成后，服务器在 `processing_url` URL 上回复 **201 Created** 状态和之前提到的常规成功 JSON 响应（现在**不包含** `processing_url` 字段），可能包括在处理之前不可用的 `nip94_event.tags.*` 字段中的可选元数据。


### 文件压缩

服务器可以应用文件压缩和其他转换，如元数据剥离。
然而，对于所有文件操作，如下载和删除，**原始**文件的 SHA-256 哈希是在 URL 字符串中标识文件的内容。

## 下载

`GET $api_url/<sha256-hash>(.ext)`

上传响应字段 `nip94_event.tags.*.url` 中提供的主要文件下载 URL
可以是上述格式，也可以不是（它可以是服务器想要的任何非标准 URL）。
如果不是，服务器仍然必须响应上一段中提到的标准 URL 的下载请求，
以使客户端能够通过仅知道 SHA-256 文件哈希就可以尝试在任何兼容 NIP-96 的服务器上下载文件。

注意，"\<sha256-hash\>" 部分是**原始**文件的哈希，**不是**经过服务器转换后的**转换**文件的哈希（如果上传的文件经过了任何服务器转换）。

对于`服务器`来说，支持 ".ext"（即"文件扩展名"）是必需的。对于`客户端`来说，在路径中附加它是可选的，尽管推荐这样做。
当存在时，`服务器`可以使用它来知道要发送哪个 `Content-Type` 头（例如：对于 ".png" 扩展名，发送 "Content-Type": "image/png"）。
文件扩展名可能不存在，因为哈希是唯一需要的字符串来唯一标识文件。

示例：`$api_url/719171db19525d9d08dd69cb716a18158a249b7b3b3ec4bbdec5698dca104b7b.png`

### 媒体转换

`服务器`可以响应一些媒体转换查询参数，并忽略它们不支持的参数，通过提供没有转换的原始媒体文件。

#### 图像转换

##### 调整大小

在上传时，`服务器`可以创建调整大小的图像变体，如缩略图，同时保持原始宽高比。
`客户端`可以使用 `w` 查询参数请求具有所需像素宽度的图像版本。
然后，`服务器`可以提供最接近参数值宽度的变体，
或动态生成的图像变体。

示例：`$api_url/<sha256-hash>.png?w=32`

## 删除

`DELETE $api_url/<sha256-hash>(.ext)`

**需要认证**

注意，`/<sha256-hash>` 部分是**原始**文件的哈希，**不是**经过服务器转换后的**转换**文件的哈希（如果上传的文件经过了任何服务器转换）。

扩展名是可选的，因为文件哈希是唯一需要的文件标识。

`服务器`应该拒绝来自原始上传者以外的用户的删除请求，并返回适当的 HTTP 响应代码（403 Forbidden）。

需要注意的是，多个用户可能已上传了相同的文件（具有相同的哈希）。在这种情况下，删除操作不应真正删除文件，而只是从文件所有者列表中移除用户的 `pubkey`（考虑到服务器只保留同一文件的一个副本，因为多次上传相同文件会导致相同的文件哈希）。

成功响应是一个 200 OK 状态，只包含基本的 JSON 字段：

```
{
  status: "success",
  message: "文件已删除。"
}
```

## 列出文件

`GET $api_url?page=x&count=y`

**需要认证**

返回与经过身份验证的用户的 pubkey 关联的文件列表。

示例响应：

```js
{
  "count": 1, // 服务器页面大小，例如 max(1, min(server_max_page_size, arg_count))
  "total": 1, // 文件总数
  "page": 0, // 当前页码
  "files": [
    {
      "tags": [
        ["ox": "719171db19525d9d08dd69cb716a18158a249b7b3b3ec4bbdec5698dca104b7b"],
        ["x": "5d2899290e0e69bcd809949ee516a4a1597205390878f780c098707a7f18e3df"],
        ["size", "123456"],
        ["alt", "一个让你发笑的表情包"],
        ["expiration",  "1715691139"],
        // ...其他元数据
      ]
      "content": "哈哈，有趣的表情包", // 说明
      "created_at": 1715691130 // 上传时间戳
    },
    ...
  ]
}
```

`files` 包含一个 NIP-94 事件数组

### 查询参数

- `page` 页码（`offset=page*count`）
- `count` 每页项目数

## 选择服务器

注意：HTTP 文件存储服务器开发者可以跳过此部分。这是为客户端开发者准备的。

文件服务器偏好事件是一个 kind 10096 可替换事件，用于选择用户想要上传文件的一个或多个服务器。服务器列为 `server` 标签：

```js
{
  // ...
  "kind": 10096,
  "content": "",
  "tags": [
    ["server", "https://file.server.one"],
    ["server", "https://file.server.two"]
  ]
}
```