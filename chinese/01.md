---
original: 602cf5c9df9150706f8a8e8b2f8f2062153777178f9732d4ab7cebf5a8ec23fe
---

NIP-01
======

基本协议流程描述
--------------

`草案` `强制性`

本NIP定义了应该被所有人实现的基本协议。新的NIP可能会为这里描述的结构和流程添加新的可选（或强制性）字段、消息和功能。

## 事件和签名

每个用户都有一个密钥对。签名、公钥和编码都按照[secp256k1曲线的Schnorr签名标准](https://bips.xyz/340)进行。

唯一存在的对象类型是`event`，它在传输时具有以下格式：

```jsonc
{
  "id": <32字节小写十六进制编码的序列化事件数据的sha256>,
  "pubkey": <32字节小写十六进制编码的事件创建者公钥>,
  "created_at": <以秒为单位的Unix时间戳>,
  "kind": <0到65535之间的整数>,
  "tags": [
    [<任意字符串>...],
    // ...
  ],
  "content": <任意字符串>,
  "sig": <64字节小写十六进制的序列化事件数据sha256哈希的签名，与"id"字段相同>
}
```

要获取`event.id`，我们对序列化的事件进行`sha256`哈希。序列化是在以下结构的UTF-8 JSON序列化字符串（如下所述）上完成的：

```
[
  0,
  <pubkey，小写十六进制字符串>,
  <created_at，数字>,
  <kind，数字>,
  <tags，非空字符串数组的数组>,
  <content，字符串>
]
```

为防止实现差异导致相同事件产生不同的事件ID，序列化时必须遵循以下规则：
- 应使用UTF-8进行编码。
- 输出的JSON中不应包含空白、换行符或其他不必要的格式。
- 内容字段中的以下字符必须按照所示进行转义，所有其他字符必须原样包含：
  - 换行符（`0x0A`），使用`\n`
  - 双引号（`0x22`），使用`\"`
  - 反斜杠（`0x5C`），使用`\\`
  - 回车符（`0x0D`），使用`\r`
  - 制表符（`0x09`），使用`\t`
  - 退格符（`0x08`），使用`\b`
  - 换页符（`0x0C`），使用`\f`

### 标签

每个标签是一个或多个字符串的数组，有一些约定围绕它们。请看下面的例子：

```jsonc
{
  "tags": [
    ["e", "5c83da77af1dec6d7289834998ad7aafbd9e2191396d75ec3cc27f5a77226f36", "wss://nostr.example.com"],
    ["p", "f7234bd4c1394dda46d09f35bd384dd30cc552ad5541990f98844fb06676e9ca"],
    ["a", "30023:f7234bd4c1394dda46d09f35bd384dd30cc552ad5541990f98844fb06676e9ca:abcd", "wss://nostr.example.com"],
    ["alt", "reply"],
    // ...
  ],
  // ...
}
```

标签数组的第一个元素被称为标签_名称_或_键_，第二个元素被称为标签_值_。因此，我们可以安全地说，上面的事件有一个`e`标签，其值为`"5c83da77af1dec6d7289834998ad7aafbd9e2191396d75ec3cc27f5a77226f36"`，一个`alt`标签，其值为`"reply"`，以此类推。第二个元素之后的所有元素都没有约定的名称。

本NIP定义了3个可以在所有事件类型中使用的标准标签，它们具有相同的含义。它们如下：

- `e`标签，用于引用一个事件：`["e", <另一个事件id的32字节小写十六进制>, <推荐的中继URL，可选>]`
- `p`标签，用于引用另一个用户：`["p", <公钥的32字节小写十六进制>, <推荐的中继URL，可选>]`
- `a`标签，用于引用一个（可能带参数的）可替换事件
    - 对于带参数的可替换事件：`["a", <kind整数>:<公钥的32字节小写十六进制>:<d标签值>, <推荐的中继URL，可选>]`
    - 对于不带参数的可替换事件：`["a", <kind整数>:<公钥的32字节小写十六进制>:, <推荐的中继URL，可选>]`

按照惯例，所有单字母（仅英文字母：a-z，A-Z）键标签都应该被中继索引，这样就可以，例如，通过使用`{"#e": ["5c83da77af1dec6d7289834998ad7aafbd9e2191396d75ec3cc27f5a77226f36"]}`过滤器来查询或订阅引用事件`"5c83da77af1dec6d7289834998ad7aafbd9e2191396d75ec3cc27f5a77226f36"`的事件。

### 种类

种类（Kinds）指定客户端应如何解释每个事件的含义以及每个事件的其他字段（例如，在kind 1的事件中，`"r"`标签可能有一个含义，而在kind 10002的事件中可能有完全不同的含义）。每个NIP可以定义一组在其他地方未定义的种类的含义。本NIP定义了两种基本种类：

- `0`: **用户元数据**：`content`设置为一个字符串化的JSON对象`{name: <用户名>, about: <字符串>, picture: <URL, 字符串>}`，描述创建事件的用户。可以设置[额外的元数据字段](24.md#kind-0)。一旦中继获得同一公钥的新事件，就可以删除旧事件。
- `1`: **文本笔记**：`content`设置为笔记的**纯文本**内容（用户想说的任何内容）。不应使用需要解析的内容，如Markdown和HTML。客户端也不应将内容解析为这些格式。

还有一个种类范围的约定，允许更容易的实验和中继实现的灵活性：

- 对于种类`n`，如果`1000 <= n < 10000 || 4 <= n < 45 || n == 1 || n == 2`，事件是**常规的**，这意味着它们都应该被中继存储。
- 对于种类`n`，如果`10000 <= n < 20000 || n == 0 || n == 3`，事件是**可替换的**，这意味着对于每个`pubkey`和`kind`的组合，中继必须只存储最新的事件，可以丢弃旧版本。
- 对于种类`n`，如果`20000 <= n < 30000`，事件是**临时的**，这意味着中继不期望存储它们。
- 对于种类`n`，如果`30000 <= n < 40000`，事件是**参数化可替换的**，这意味着对于每个`pubkey`、`kind`和`d`标签第一个值的组合，中继必须只存储最新的事件，可以丢弃旧版本。

对于时间戳相同的可替换事件，应保留id最小（字典序第一）的事件，丢弃其他事件。

当回答可替换事件的`REQ`消息，如`{"kinds":[0],"authors":[<hex-key>]}`时，即使中继存储了多个版本，也应该只返回最新的一个。

这些只是约定，中继实现可能会有所不同。

## 客户端和中继之间的通信

中继暴露一个WebSocket端点，客户端可以连接到该端点。客户端应该为每个中继打开一个单独的WebSocket连接，并将其用于所有订阅。中继可以限制来自特定IP/客户端等的连接数量。

### 从客户端到中继：发送事件和创建订阅

客户端可以发送3种类型的消息，这些消息必须是JSON数组，按照以下模式：

  * `["EVENT", <如上定义的事件JSON>]`，用于发布事件。
  * `["REQ", <subscription_id>, <filters1>, <filters2>, ...]`，用于请求事件和订阅新更新。
  * `["CLOSE", <subscription_id>]`，用于停止先前的订阅。

`<subscription_id>`是一个任意的、非空的最大长度为64个字符的字符串。它表示每个连接的订阅。中继必须为每个WebSocket连接独立管理`<subscription_id>`。`<subscription_id>`不保证全局唯一。

`<filtersX>`是一个JSON对象，决定在该订阅中将发送哪些事件，它可以有以下属性：

```json
{
  "ids": <事件id列表>,
  "authors": <小写公钥列表，事件的公钥必须是其中之一>,
  "kinds": <种类数字列表>,
  "#<单个字母 (a-zA-Z)>": <标签值列表，对于#e — 事件id列表，对于#p — 公钥列表，等等>,
  "since": <整数Unix时间戳（秒）。事件必须有created_at >= 此值才能通过>,
  "until": <整数Unix时间戳（秒）。事件必须有created_at <= 此值才能通过>,
  "limit": <中继应在初始查询中返回的最大事件数>
}
```

在收到`REQ`消息后，中继应查询其内部数据库并返回匹配过滤器的事件，然后存储该过滤器并将所有未来收到的事件再次发送到同一WebSocket，直到WebSocket关闭。如果收到具有相同`<subscription_id>`的`CLOSE`事件，或者使用相同`<subscription_id>`发送新的`REQ`，在这种情况下，中继必须覆盖先前的订阅。

包含列表的过滤器属性（`ids`、`authors`、`kinds`和像`#e`这样的标签过滤器）是包含一个或多个值的JSON数组。数组中至少有一个值必须与事件中的相关字段匹配，才能认为条件匹配。对于像`authors`和`kind`这样的标量事件属性，事件中的属性必须包含在过滤器列表中。对于像`#e`这样的标签属性，事件可能有多个值，事件和过滤器条件值必须至少有一个共同项。

`ids`、`authors`、`#e`和`#p`过滤器列表必须包含精确的64字符小写十六进制值。

`since`和`until`属性可用于指定订阅中返回的事件的时间范围。如果过滤器包括`since`属性，则`created_at`大于或等于`since`的事件被认为匹配过滤器。`until`属性类似，只是`created_at`必须小于或等于`until`。简而言之，如果满足`since <= created_at <= until`，则事件匹配过滤器。

必须匹配过滤器的所有指定条件，事件才能通过过滤器，即多个条件被解释为`&&`条件。

一个`REQ`消息可能包含多个过滤器。在这种情况下，匹配任何过滤器的事件都将被返回，即多个过滤器被解释为`||`条件。

过滤器的`limit`属性仅对初始查询有效，之后必须忽略。当存在`limit: n`时，假定初始查询返回的事件将是按`created_at`排序的最后`n`个事件。较新的事件应该首先出现，如果有相同时间戳的事件，id最小（字典序第一）的事件应该在前。返回少于`limit`指定的事件数是安全的，但预期中继不会返回（远）超过请求的事件数，以免客户端不必要地被数据淹没。

### 从中继到客户端：发送事件和通知

中继可以发送5种类型的消息，这些消息也必须是JSON数组，按照以下模式：

  * `["EVENT", <subscription_id>, <如上定义的事件JSON>]`，用于发送客户端请求的事件。
  * `["OK", <event_id>, <true|false>, <message>]`，用于表示接受或拒绝`EVENT`消息。
  * `["EOSE", <subscription_id>]`，用于表示_存储事件的结束_和新接收的实时事件的开始。
  * `["CLOSED", <subscription_id>, <message>]`，用于表示服务器端结束了订阅。
  * `["NOTICE", <message>]`，用于向客户端发送人类可读的错误消息或其他内容。

本NIP未定义`NOTICE`消息应如何发送或处理的规则。

- `EVENT`消息必须只与客户端之前发起的订阅（使用上述`REQ`消息）相关的订阅ID一起发送。
- `OK`消息必须作为对从客户端接收的`EVENT`消息的响应发送，当事件被中继接受时，第3个参数必须设置为`
true`，否则为`false`。第4个参数必须始终存在，但当第3个参数为`true`时可以是空字符串，否则必须是由机器可读的单词前缀后跟`:`，然后是人类可读的消息组成的字符串。一些例子：
  * `["OK", "b1a649ebe8...", true, ""]`
  * `["OK", "b1a649ebe8...", true, "pow: difficulty 25>=24"]`
  * `["OK", "b1a649ebe8...", true, "duplicate: already have this event"]`
  * `["OK", "b1a649ebe8...", false, "blocked: you are banned from posting here"]`
  * `["OK", "b1a649ebe8...", false, "blocked: please register your pubkey at https://my-expensive-relay.example.com"]`
  * `["OK", "b1a649ebe8...", false, "rate-limited: slow down there chief"]`
  * `["OK", "b1a649ebe8...", false, "invalid: event creation date is too far off from the current time"]`
  * `["OK", "b1a649ebe8...", false, "pow: difficulty 26 is less than 30"]`
  * `["OK", "b1a649ebe8...", false, "error: could not connect to the database"]`
- 当中继拒绝满足`REQ`请求时，必须发送`CLOSED`消息作为响应。当中继决定在客户端断开连接或发送`CLOSE`之前终止其端的订阅时，也可以发送此消息。此消息使用与`OK`消息相同的模式，包含机器可读前缀和人类可读消息。一些例子：
  * `["CLOSED", "sub1", "duplicate: sub1 already opened"]`
  * `["CLOSED", "sub1", "unsupported: filter contains unknown elements"]`
  * `["CLOSED", "sub1", "error: could not connect to the database"]`
  * `["CLOSED", "sub1", "error: shutting down idle subscription"]`
- `OK`和`CLOSED`的标准化机器可读前缀是：`duplicate`、`pow`、`blocked`、`rate-limited`、`invalid`和`error`（当以上都不适用时）。