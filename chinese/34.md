---
original: 82185f805d8161f4fde919d473327b80e918d660b2b63c2d174794b9d8f9faf9
---

NIP-34
======

`git` 相关内容
-----------

`草案` `可选`

本 NIP 定义了使用 Nostr 进行与 [`git`](https://git-scm.com/) 相关的代码协作的所有方式。

## 仓库公告

Git 仓库托管在支持 Git 的服务器上，但可以使用 Nostr 事件来宣布它们的存在，以及它们接收补丁、错误报告和一般评论的意愿。

```jsonc
{
  "kind": 30617,
  "content": "",
  "tags": [
    ["d", "<repo-id>"], // 通常是短横线分隔的小写名称
    ["name", "<人类可读的项目名称>"],
    ["description", "简短的人类可读项目描述>"],
    ["web", "<浏览用 URL>", ...], // 网页 URL，如果使用的 git 服务器提供这样的功能
    ["clone", "<git 克隆用 URL>", ...], // 提供给 `git clone` 的 URL，以便任何人都可以克隆它
    ["relays", "<中继 URL>", ...] // 此仓库将监控补丁和问题的中继
    ["r", "<最早的唯一提交 ID>", "euc"]
    ["maintainers", "<其他认可的维护者>", ...]
  ]
}
```

标签 `web`、`clone`、`relays`、`maintainers` 可以有多个值。

带有 `"euc"` 标记的 `r` 标签应该是该仓库最早的唯一提交 ID，用于在分叉中识别它，并将其与可能代表本质上相同项目的其他托管仓库分组。在大多数情况下，它将是仓库的根提交。如果两个项目之间发生永久分叉，则应使用分叉后的第一个提交。

除 `d` 外，所有标签都是可选的。

## 仓库状态公告

仓库中分支和标签状态的可选真实来源。

```jsonc
{
  "kind": 30618,
  "content": "",
  "tags": [
    ["d", "<repo-id>"], // 与相应的仓库公告中的标识符匹配
    ["refs/<heads|tags>/<分支或标签名称>","<提交 ID>"]
    ["HEAD", "ref: refs/heads/<分支名称>"]
  ]
}
```

`refs` 标签可以出现多次，或者不出现。

如果没有 `refs` 标签，则作者不再使用此事件跟踪仓库状态。与 [NIP-09](09.md) 删除不同，这种方法使作者能够在以后重新开始跟踪状态。

`refs` 标签可以选择性地扩展，以使客户端能够识别一个引用领先多少个提交：

```jsonc
{
  "tags": [
    ["refs/<heads|tags>/<分支或标签名称>", "<提交 ID>", "<简写父提交 ID>", "<简写祖父提交>", ...],
  ]
}
```

## 补丁

任何人都可以向任何仓库发送补丁。发送到特定仓库的补丁应该发送到该仓库公告事件的 `"relays"` 标签中指定的中继。补丁事件应包含一个指向该仓库公告地址的 `a` 标签。

补丁集中的补丁应包含一个指向前一个补丁的 NIP-10 `e` `reply` 标签。

补丁修订中的第一个补丁应包含一个指向原始根补丁的 NIP-10 `e` `reply`。

```jsonc
{
  "kind": 1617,
  "content": "<patch>", // <git format-patch> 的内容
  "tags": [
    ["a", "30617:<base-repo-owner-pubkey>:<base-repo-id>"],
    ["r", "<仓库最早的唯一提交 ID>"] // 使客户端可以订阅发送到本地 git 仓库的所有补丁
    ["p", "<仓库所有者>"],
    ["p", "<其他用户>"], // 可选择将补丁发送给其他用户以引起他们的注意

    ["t", "root"], // 在系列中的其他补丁中省略
    // 修订中的第一个补丁
    ["t", "root-revision"],

    // 当希望合并的补丁具有稳定的提交 ID 时的可选标签
    // 这些字段对于确保应用补丁后的提交与提议者机器上的 ID 相同是必要的
    // 如果维护者不关心这些事情，所有这些标签都可以省略
    ["commit", "<当前提交 ID>"],
    ["r", "<当前提交 ID>"] // 使客户端可以找到特定提交的现有补丁
    ["parent-commit", "<父提交 ID>"],
    ["commit-pgp-sig", "-----BEGIN PGP SIGNATURE-----..."], // 未签名提交为空字符串
    ["committer", "<姓名>", "<电子邮件>", "<时间戳>", "<时区偏移（分钟）>"],
  ]
}
```

系列中的第一个补丁可能是 `git format-patch` 生成的格式的封面信。

## 问题

问题是与仓库相关的人类可读的对话线程的 Markdown 文本：错误报告、功能请求、问题或任何类型的评论。与补丁一样，这些应该发送到该仓库公告事件的 `"relays"` 标签中指定的中继。

```jsonc
{
  "kind": 1621,
  "content": "<markdown 文本>",
  "tags": [
    ["a", "30617:<base-repo-owner-pubkey>:<base-repo-id>"],
    ["p", "<仓库所有者>"]
  ]
}
```

## 回复

回复也是 Markdown 文本。不同之处在于它们必须作为对 `kind:1621` _问题_ 或 `kind:1617` _补丁_ 事件的回复发出。回复和补丁的线程应遵循 NIP-10 规则。

```jsonc
{
  "kind": 1622,
  "content": "<markdown 文本>",
  "tags": [
    ["a", "30617:<base-repo-owner-pubkey>:<base-repo-id>", "<中继 URL>"],
    ["e", "<问题或补丁 ID（十六进制）>", "", "root"],

    // 必要时应在此处应用其他 "e" 和 "p" 标签，遵循 NIP-10 的线程规则
    ["p", "<补丁作者公钥（十六进制）>", "", "mention"],
    ["e", "<前一个回复 ID（十六进制）>", "", "reply"],
    // ...
  ]
}
```

## 状态

根补丁和问题有一个默认为"开放"的状态，可以通过发出状态事件来设置。

```jsonc
{
  "kind": 1630, // 开放
  "kind": 1631, // 补丁已应用/合并；问题已解决
  "kind": 1632, // 已关闭
  "kind": 1633, // 草稿
  "content": "<markdown 文本>",
  "tags": [
    ["e", "<问题或原始根补丁 ID（十六进制）>", "", "root"],
    ["e", "<已接受修订根 ID（十六进制）>", "", "reply"], // 适用于应用修订时
    ["p", "<仓库所有者>"],
    ["p", "<根事件作者>"],
    ["p", "<修订作者>"],

    // 可选，用于提高订阅过滤效率
    ["a", "30617:<base-repo-owner-pubkey>:<base-repo-id>", "<中继 URL>"],
    ["r", "<仓库最早的唯一提交 ID>"]

    // `1631` 状态的可选标签
    ["e", "<已应用或合并的补丁事件 ID>", "", "mention"], // 每个都有
    // 当合并时
    ["merge-commit", "<合并提交 ID>"]
    ["r", "<合并提交 ID>"]
    // 当应用时
    ["applied-as-commits", "<主分支中的提交 ID>", ...]
    ["r", "<已应用的提交 ID>"] // 每个都有
  ]
}
```

创建日期最大的状态事件有效。

补丁修订的状态默认为根补丁的状态，或者如果根补丁的状态为 `1631` 且补丁修订未在 `1631` 事件中标记，则默认为 `1632`（已关闭）。

## 可能稍后添加的内容

- "分支合并"类型（指定从何处获取要合并的分支的 URL）
- 内联文件评论类型（我们可能需要一个用于补丁，另一个用于已合并文件）