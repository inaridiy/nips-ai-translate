---
original: a924c69ed99e33a38df7b05a6d2d6005e87b3ec71018dcad8fe9e02759afb635
---

NIP-49
======

秘密鍵の暗号化
--------------

`draft` `optional`

この NIP は、クライアントがユーザーの秘密鍵をパスワードで暗号化（および復号化）する方法を定義します。

対称暗号化鍵の導出
------------------

PASSWORD = ユーザーから読み取ります。パスワードは、他のコンピューター/クライアントで同一に入力できるようにするため、Unicode の NFKC 形式に正規化する必要があります。

LOG\_N = ユーザーまたは実装者が、2の累乗を表す1バイト（例：18は262,144を表す）を選択します。これは scrypt のラウンド数として使用されます。大きな数値はより多くの時間とメモリを必要とし、より高い保護を提供します：

    | LOG_N | 必要なメモリ    | 高速コンピューターでの概算時間 |
    |-------|----------------|----------------------------|
    | 16    | 64 MiB         | 100 ミリ秒                  |
    | 18    | 256 MiB        |                            |
    | 20    | 1 GiB          | 2 秒                       |
    | 21    | 2 GiB          |                            |
    | 22    | 4 GiB          |                            |

SALT = 16バイトのランダムデータ

SYMMETRIC_KEY = scrypt(password=PASSWORD, salt=SALT, log\_n=LOG\_N, r=8, p=1)

対称鍵は32バイトの長さである必要があります。

この対称暗号化鍵は一時的なものであり、使用後にゼロクリアして破棄し、他の目的で保存または再利用しないでください。

秘密鍵の暗号化
--------------

秘密鍵の暗号化プロセスは以下の通りです：

PRIVATE\_KEY = ユーザーの秘密（シークレット）secp256k1鍵を32バイトの生データとして（16進数やbech32エンコードではありません！）

KEY\_SECURITY\_BYTE = 以下のいずれか：

* 0x00 - 鍵が安全でない方法で扱われたことが知られている場合（暗号化されずに保存された、暗号化されずにコピー＆ペーストされた等）
* 0x01 - 鍵が安全でない方法で扱われたことが知られていない場合（暗号化されずに保存された、暗号化されずにコピー＆ペーストされた等）
* 0x02 - クライアントがこのデータを追跡しない場合

ASSOCIATED\_DATA = KEY\_SECURITY\_BYTE

NONCE = 24バイトのランダムノンス

CIPHERTEXT = XChaCha20-Poly1305(
    plaintext=PRIVATE\_KEY,
    associated_data=ASSOCIATED\_DATA,
    nonce=NONCE,
    key=SYMMETRIC\_KEY
)

VERSION\_NUMBER = 0x02

CIPHERTEXT_CONCATENATION = concat(
    VERSION\_NUMBER,
    LOG\_N,
    SALT,
    NONCE,
    ASSOCIATED\_DATA,
    CIPHERTEXT
)

ENCRYPTED\_PRIVATE\_KEY = bech32_encode('ncryptsec', CIPHERTEXT\_CONCATENATION)

bech32エンコーディング前の出力は91バイトの長さである必要があります。

復号化プロセスは逆の順序で行われます。

テストデータ
------------

## パスワードのUnicode正規化

以下のパスワード入力："ÅΩẛ̣"
- Unicodeコードポイント：U+212B U+2126 U+1E9B U+0323
- UTF-8バイト：[0xE2, 0x84, 0xAB, 0xE2, 0x84, 0xA6, 0xE1, 0xBA, 0x9B, 0xCC, 0xA3]

scryptで使用する前に、Unicode正規化されたNFKC形式に変換する必要があります："ÅΩẛ̣"
- Unicodeコードポイント：U+00C5 U+03A9 U+1E69
- UTF-8バイト：[0xC3, 0x85, 0xCE, 0xA9, 0xE1, 0xB9, 0xA9]

## 暗号化

暗号化プロセスは、ランダムノンスのため非決定的です。

## 復号化

以下の暗号化された秘密鍵：

`ncryptsec1qgg9947rlpvqu76pj5ecreduf9jxhselq2nae2kghhvd5g7dgjtcxfqtd67p9m0w57lspw8gsq6yphnm8623nsl8xn9j4jdzz84zm3frztj3z7s35vpzmqf6ksu8r89qk5z2zxfmu5gv8th8wclt0h4p`

パスワード='nostr'とlog_n=16で復号化すると、以下の16進数エンコードされた秘密鍵が得られます：

`3501454135014541350145413501453fefb02227e449e57cf4d3a3ce05378683`

議論
----

### 鍵導出について

パスワードは暗号鍵として適していません。暗号鍵として使用する前に、以下の2つのことが必要です：

1. パスワードから決定論的に暗号化鍵を作成し、ビットの均一な機能的にランダムな分布を持たせ、対称暗号化アルゴリズムの前提条件を満たすこと。
2. 多くのパスワードを試行する総当たり攻撃による復号化の試みを著しく妨げるために、遅い不可逆アルゴリズムをプロセスに挿入すること。

これらは、パスワードベースの鍵導出関数を使用することで達成されます。我々は scrypt を使用します。scrypt は最大限のメモリハードであることが証明されており、2015年にargon2が競争に勝ったにもかかわらず、複数の暗号学者が著者に対してargon2よりも優れていると指摘しています。

### 対称暗号化アルゴリズムについて

XChaCha20-Poly1305は、一般的に暗号学者によってAESよりも好まれ、米国政府との関連性が低いです。これ（または'X'なしの初期バリアント）は広く使用されており、TLSやOpenSSHで使用され、ほとんどの現代の暗号ライブラリで利用可能です。

推奨事項
--------

ユーザーがこれらの暗号化された秘密鍵をnostrに公開することは推奨されません。攻撃者が多くの暗号化された秘密鍵を収集できる場合、鍵の解読が容易になる可能性があるためです。

クライアントがメモリを解放する前に、パスワードと秘密鍵のメモリをゼロクリアすることを推奨します。