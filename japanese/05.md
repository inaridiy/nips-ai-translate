---
original: c2c9f9c098188cf81b5ffe55f7d183353871fa3eb599c1ecea0c46e59b27fa8e
---

NIP-05
======

Nostrキーをドメインネームシステム（DNS）ベースのインターネット識別子にマッピングする
----------------------------------------------------

`final` `optional`

種類 `0` (`ユーザーメタデータ`) のイベントでは、キー `"nip05"` に[インターネット識別子](https://datatracker.ietf.org/doc/html/rfc5322#section-3.4.1)（メールアドレスに似た形式）を値として指定できます。上記のリンクには非常に自由度の高い「インターネット識別子」の仕様がありますが、NIP-05では `<local-part>` の部分が `a-z0-9-_.` の文字に制限されると想定しています（大文字小文字は区別しません）。

これを見たクライアントは、識別子を `<local-part>` と `<domain>` に分割し、これらの値を使用して `https://<domain>/.well-known/nostr.json?name=<local-part>` にGETリクエストを行います。

結果は、`"names"` というキーを持つJSONドキュメントオブジェクトであるべきで、これは名前を16進数形式の公開鍵にマッピングしたものです。指定された `<name>` の公開鍵が `ユーザーのメタデータ` イベントの `pubkey` と一致する場合、クライアントは指定された公開鍵が実際にその識別子で参照できると結論付けます。

### 例

クライアントが次のようなイベントを見た場合：

```json
{
  "pubkey": "b0635d6a9851d3aed0cd6c495b282167acf761729078d975fc341b22650b07b9",
  "kind": 0,
  "content": "{\"name\": \"bob\", \"nip05\": \"bob@example.com\"}"
  ...
}
```

`https://example.com/.well-known/nostr.json?name=bob` にGETリクエストを行い、次のような応答を受け取ります：

```json
{
  "names": {
    "bob": "b0635d6a9851d3aed0cd6c495b282167acf761729078d975fc341b22650b07b9"
  }
}
````

または、**推奨される** `"relays"` 属性を含む場合：

```json
{
  "names": {
    "bob": "b0635d6a9851d3aed0cd6c495b282167acf761729078d975fc341b22650b07b9"
  },
  "relays": {
    "b0635d6a9851d3aed0cd6c495b282167acf761729078d975fc341b22650b07b9": [ "wss://relay.example.com", "wss://relay2.example.com" ]
  }
}
````

公開鍵が `"names"` で指定されたものと一致する場合（上記の例のように）、関連付けが正しいことを意味し、`"nip05"` 識別子が有効で表示できることになります。

推奨される `"relays"` 属性には、公開鍵をプロパティとし、リレーURLの配列を値とするオブジェクトが含まれる場合があります。これが存在する場合、クライアントが特定のユーザーを見つけられるリレーを学ぶのに役立ちます。クエリ文字列に基づいて動的に `/.well-known/nostr.json` ファイルを提供するWebサーバーは、利用可能な場合、同じ応答で提供するすべての名前のリレーデータも提供すべきです（SHOULD）。

## NIP-05識別子からユーザーを見つける

クライアントは、_インターネット識別子_からユーザーの公開鍵を見つけるサポートを実装できます。フローは上記と同じですが、逆順になります：まずクライアントが_well-known_ URLを取得し、そこからユーザーの公開鍵を取得し、次にそのユーザーの種類 `0` のイベントを取得しようとして、一致する `"nip05"` があるかどうかを確認します。

## 注意事項

### クライアントは常に公開鍵を追跡し、NIP-05アドレスは追跡しない

例えば、`bob@bob.com` が公開鍵 `abc...def` を持っていることを発見した後、ユーザーがそのプロフィールをフォローするボタンをクリックした場合、クライアントは `abc...def` への主要な参照を保持する必要があり、`bob@bob.com` への参照は保持しません。何らかの理由で、`https://bob.com/.well-known/nostr.json?name=bob` のアドレスが将来的に公開鍵 `1d2...e3f` を返すようになった場合、クライアントはユーザーのフォローしているプロフィールリストで `abc...def` を置き換えてはいけません（ただし、その時点で無効な `"nip05"` プロパティになるため、そのユーザーに対して "bob@bob.com" の表示を停止する必要があります）。

### 公開鍵は16進数形式でなければならない

キーは16進数形式で返される必要があります。NIP-19の `npub` 形式のキーは、クライアントUIでの表示にのみ使用され、このNIPでは使用されません。

### ユーザー発見の実装提案

クライアントはこれを使用して、ユーザーが他のプロフィールを検索できるようにすることもできます。クライアントに検索ボックスなどがある場合、ユーザーはそこに "bob@example.com" と入力でき、クライアントはそれを認識して適切なクエリを実行し、公開鍵を取得してユーザーに提案することができます。

### ドメインのみを識別子として表示する

クライアントは識別子 `_@domain` を「ルート」識別子として扱い、`<domain>` のみを表示することを選択できます。例えば、Bobが `bob.com` を所有している場合、`bob@bob.com` のような識別子は冗長かもしれません。代わりに、Bobは識別子 `_@bob.com` を使用し、Nostrクライアントがそれをすべての目的で単に `bob.com` として表示し扱うことを期待できます。

### `/.well-known/nostr.json?name=<local-part>` 形式の理由

`<local-part>` をパスの一部ではなくクエリ文字列として追加することで、プロトコルはオンデマンドでJSONを生成できる動的サーバーと、複数の名前を含むJSONファイルを持つ静的サーバーの両方をサポートできます。

### JavaScriptアプリからのアクセスを許可する

JavaScriptのNostrアプリは、ブラウザの[CORS][]ポリシーによってユーザーのドメイン上の `/.well-known/nostr.json` へのアクセスが制限される場合があります。CORSがJSによるリソースの読み込みを妨げる場合、JSプログラムはそれをリソースが存在しないのと同じネットワーク障害として認識するため、純粋なJSアプリが障害がCORS問題によって引き起こされたことを確実にユーザーに伝えることはできません。`/.well-known/nostr.json` ファイルのリクエスト時にネットワーク障害を確認するJSのNostrアプリは、ユーザーにサーバーのCORSポリシーを確認するよう推奨することができます。例：

```bash
$ curl -sI https://example.com/.well-known/nostr.json?name=bob | grep -i ^Access-Control
Access-Control-Allow-Origin: *
```

ユーザーは、純粋なJSアプリが最新のブラウザで検証できるようにするために、`/.well-known/nostr.json` がHTTPヘッダー `Access-Control-Allow-Origin: *` で提供されていることを確認する必要があります。

[CORS]: https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS

### セキュリティ制約

`/.well-known/nostr.json` エンドポイントは、HTTPリダイレクトを返してはいけません（MUST NOT）。

フェッチャーは、`/.well-known/nostr.json` エンドポイントによって与えられるHTTPリダイレクトを無視しなければなりません（MUST）。