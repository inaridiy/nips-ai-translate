---
original: 602cf5c9df9150706f8a8e8b2f8f2062153777178f9732d4ab7cebf5a8ec23fe
---

NIP-01
======

基本プロトコルフローの説明
---------------------------

`draft` `mandatory`

この NIP は、全ての人が実装すべき基本プロトコルを定義しています。新しい NIP は、ここで説明される構造とフローに新しいオプション（または必須）のフィールド、メッセージ、機能を追加する可能性があります。

## イベントと署名

各ユーザーは鍵ペアを持っています。署名、公開鍵、エンコーディングは[曲線 `secp256k1` のシュノア署名標準](https://bips.xyz/340)に従って行われます。

存在する唯一のオブジェクトタイプは `event` で、ワイヤー上では以下の形式を持ちます：

```jsonc
{
  "id": <シリアライズされたイベントデータのsha256の32バイト小文字16進エンコード>,
  "pubkey": <イベント作成者の公開鍵の32バイト小文字16進エンコード>,
  "created_at": <Unix タイムスタンプ（秒）>,
  "kind": <0から65535までの整数>,
  "tags": [
    [<任意の文字列>...],
    // ...
  ],
  "content": <任意の文字列>,
  "sig": <シリアライズされたイベントデータ（"id"フィールドと同じ）のsha256ハッシュの署名の64バイト小文字16進>
}
```

`event.id` を取得するには、シリアライズされたイベントの `sha256` を計算します。シリアライズは、以下の構造の UTF-8 JSON シリアライズ文字列（以下で説明）に対して行われます：

```
[
  0,
  <pubkey, 小文字16進文字列として>,
  <created_at, 数値として>,
  <kind, 数値として>,
  <tags, null以外の文字列の配列の配列として>,
  <content, 文字列として>
]
```

実装の違いによって同じイベントに対して異なるイベントIDが生成されるのを防ぐため、シリアライズ時には以下のルールを必ず守る必要があります：
- エンコーディングにはUTF-8を使用すること。
- 出力JSONに空白、改行、その他の不要な書式を含めないこと。
- contentフィールド内の以下の文字は示されたようにエスケープし、その他の文字はそのまま含めること：
  - 改行（`0x0A`）は `\n` を使用
  - ダブルクォート（`0x22`）は `\"` を使用
  - バックスラッシュ（`0x5C`）は `\\` を使用
  - キャリッジリターン（`0x0D`）は `\r` を使用
  - タブ文字（`0x09`）は `\t` を使用
  - バックスペース（`0x08`）は `\b` を使用
  - フォームフィード（`0x0C`）は `\f` を使用

### タグ

各タグは1つ以上の文字列の配列で、それらに関するいくつかの規則があります。以下の例を見てください：

```jsonc
{
  "tags": [
    ["e", "5c83da77af1dec6d7289834998ad7aafbd9e2191396d75ec3cc27f5a77226f36", "wss://nostr.example.com"],
    ["p", "f7234bd4c1394dda46d09f35bd384dd30cc552ad5541990f98844fb06676e9ca"],
    ["a", "30023:f7234bd4c1394dda46d09f35bd384dd30cc552ad5541990f98844fb06676e9ca:abcd", "wss://nostr.example.com"],
    ["alt", "reply"],
    // ...
  ],
  // ...
}
```

タグ配列の最初の要素はタグの _名前_ または _キー_ と呼ばれ、2番目の要素は _値_ と呼ばれます。したがって、上記のイベントには `e` タグが `"5c83da77af1dec6d7289834998ad7aafbd9e2191396d75ec3cc27f5a77226f36"` に設定され、`alt` タグが `"reply"` に設定されているなどと安全に言えます。2番目の要素以降の要素には慣例的な名前はありません。

この NIP では、全てのイベントの種類で同じ意味で使用できる3つの標準タグを定義しています。以下の通りです：

- `e` タグ：イベントを参照するために使用されます：`["e", <別のイベントのidの32バイト小文字16進>, <推奨リレーURL、オプション>]`
- `p` タグ：別のユーザーを参照するために使用されます：`["p", <公開鍵の32バイト小文字16進>, <推奨リレーURL、オプション>]`
- `a` タグ：（パラメータ化された可能性のある）置換可能なイベントを参照するために使用されます
    - パラメータ化された置換可能なイベントの場合：`["a", <種類の整数>:<公開鍵の32バイト小文字16進>:<dタグの値>, <推奨リレーURL、オプション>]`
    - パラメータ化されていない置換可能なイベントの場合：`["a", <種類の整数>:<公開鍵の32バイト小文字16進>:, <推奨リレーURL、オプション>]`

慣例として、全ての単一文字（英語アルファベットのみ：a-z、A-Z）のキータグはリレーによってインデックス化されることが期待されています。これにより、例えば `{"#e": ["5c83da77af1dec6d7289834998ad7aafbd9e2191396d75ec3cc27f5a77226f36"]}` フィルターを使用して、イベント `"5c83da77af1dec6d7289834998ad7aafbd9e2191396d75ec3cc27f5a77226f36"` を参照するイベントをクエリまたはサブスクライブすることが可能になります。

### 種類

種類は、クライアントが各イベントの意味と各イベントの他のフィールドをどのように解釈すべきかを指定します（例えば、`"r"` タグは種類1のイベントでは一つの意味を持ち、種類10002のイベントでは全く異なる意味を持つ可能性があります）。各 NIP は、他の場所で定義されていない一連の種類の意味を定義することができます。この NIP では、2つの基本的な種類を定義しています：

- `0`: **ユーザーメタデータ**：`content` は、イベントを作成したユーザーを説明する文字列化された JSON オブジェクト `{name: <ユーザー名>, about: <文字列>, picture: <URL, 文字列>}` に設定されます。[追加のメタデータフィールド](24.md#kind-0)を設定することもできます。リレーは、同じ公開鍵に対して新しいイベントを受け取った場合、古いイベントを削除することができます。
- `1`: **テキストノート**：`content` はノートの**プレーンテキスト**内容（ユーザーが言いたいこと）に設定されます。Markdown や HTML のようにパースする必要のあるコンテンツは使用すべきではありません。クライアントもそれらとしてコンテンツをパースすべきではありません。

また、リレー実装の実験と柔軟性を容易にするための種類の範囲に関する規則も定義しています：

- `n` が `1000 <= n < 10000 || 4 <= n < 45 || n == 1 || n == 2` の場合、イベントは**通常**で、リレーによって保存されることが期待されます。
- `n` が `10000 <= n < 20000 || n == 0 || n == 3` の場合、イベントは**置換可能**で、`pubkey` と `kind` の各組み合わせに対して、最新のイベントのみがリレーによって保存される必要があり、古いバージョンは破棄される可能性があります。
- `n` が `20000 <= n < 30000` の場合、イベントは**一時的**で、リレーによって保存されることは期待されません。
- `n` が `30000 <= n < 40000` の場合、イベントは**パラメータ化された置換可能**で、`pubkey`、`kind`、`d` タグの最初の値の各組み合わせに対して、最新のイベントのみがリレーによって保存される必要があり、古いバージョンは破棄される可能性があります。

同じタイムスタンプを持つ置換可能なイベントの場合、最も低い id（辞書順で最初）のイベントが保持され、他は破棄されるべきです。

`{"kinds":[0],"authors":[<16進キー>]}` のような置換可能なイベントに対する `REQ` メッセージに応答する際、リレーが複数のバージョンを保存している場合でも、最新のものだけを返すべきです（SHOULD）。

これらは単なる規則であり、リレーの実装は異なる場合があります。

## クライアントとリレー間の通信

リレーは、クライアントが接続できるウェブソケットエンドポイントを公開します。クライアントは各リレーに対して単一のウェブソケット接続を開き、全てのサブスクリプションにそれを使用すべきです（SHOULD）。リレーは特定のIP/クライアント/その他からの接続数を制限する場合があります（MAY）。

### クライアントからリレーへ：イベントの送信とサブスクリプションの作成

クライアントは3種類のメッセージを送信でき、それらは以下のパターンに従ったJSON配列でなければなりません：

  * `["EVENT", <上記で定義されたイベントJSON>]`：イベントを公開するために使用されます。
  * `["REQ", <サブスクリプションID>, <フィルター1>, <フィルター2>, ...]`：イベントをリクエストし、新しい更新をサブスクライブするために使用されます。
  * `["CLOSE", <サブスクリプションID>]`：以前のサブスクリプションを停止するために使用されます。

`<サブスクリプションID>` は、最大長64文字の任意の空でない文字列です。これは接続ごとのサブスクリプションを表します。リレーは各WebSocket接続に対して独立して `<サブスクリプションID>` を管理しなければなりません（MUST）。`<サブスクリプションID>` がグローバルに一意であることは保証されません。

`<フィルターX>` は、そのサブスクリプションで送信されるイベントを決定するJSONオブジェクトで、以下の属性を持つことができます：

```json
{
  "ids": <イベントIDのリスト>,
  "authors": <小文字の公開鍵のリスト、イベントの公開鍵はこれらの1つでなければならない>,
  "kinds": <種類の数値のリスト>,
  "#<単一文字 (a-zA-Z)>": <タグ値のリスト、#eの場合はイベントIDのリスト、#pの場合は公開鍵のリストなど>,
  "since": <秒単位の整数Unixタイムスタンプ。イベントはこれ以上のcreated_atを持つ必要がある>,
  "until": <秒単位の整数Unixタイムスタンプ。イベントはこれ以下のcreated_atを持つ必要がある>,
  "limit": <リレーが初期クエリで返すべき最大イベント数>
}
```

`REQ` メッセージを受信すると、リレーは内部データベースをクエリし、フィルターに一致するイベントを返し、そのフィルターを保存し、ウェブソケットが閉じられるまで、または同じ `<サブスクリプションID>` を使用して新しい `REQ` が送信されるまで（この場合、リレーは以前のサブスクリプションを上書きしなければなりません）、受信する全ての将来のイベントを同じウェブソケットに送信し続けるべきです（SHOULD）。

リストを含むフィルター属性（`ids`、`authors`、`kinds`、`#e` のようなタグフィルター）は、1つ以上の値を持つJSON配列です。条件が一致とみなされるためには、配列の値の少なくとも1つがイベントの関連フィールドと一致する必要があります。`authors` や `kind` のようなスカラーイベント属性の場合、イベントの属性がフィルターリストに含まれている必要があります。`#e` のような、イベントが複数の値を持つ可能性のあるタグ属性の場合、イベントとフィルター条件の値は少なくとも1つの項目を共通して持つ必要があります。

`ids`、`authors`、`#e`、`#p` フィルターリストは、正確に64文字の小文字16進値を含まなければなりません（MUST）。


`since` および `until` プロパティを使用して、サブスクリプションで返されるイベントの時間範囲を指定できます。フィルターに `since` プロパティが含まれている場合、`created_at` が `since` 以上のイベントがフィルターに一致すると見なされます。`until` プロパティも同様ですが、`created_at` が `until` 以下でなければなりません。簡単に言えば、`since <= created_at <= until` が成り立つ場合、イベントはフィルターに一致します。

イベントがフィルターを通過するためには、指定されたフィルターの全ての条件が一致する必要があります。つまり、複数の条件は `&&` 条件として解釈されます。

`REQ` メッセージには複数のフィルターを含めることができます。この場合、フィルターのいずれかに一致するイベントが返されます。つまり、複数のフィルターは `||` 条件として解釈されます。

フィルターの `limit` プロパティは初期クエリにのみ有効で、その後は無視されなければなりません（MUST）。`limit: n` が存在する場合、初期クエリで返されるイベントは `created_at` で順序付けられた最後の `n` イベントであると想定されます。新しいイベントが先に表示され、同点の場合は最も低い id（辞書順で最初）のイベントが先に表示されるべきです。`limit` で指定された数よりも少ないイベントを返すことは安全ですが、リレーはクライアントが不必要にデータで圧倒されないように、リクエストされた数よりも（はるかに）多くのイベントを返さないことが期待されます。

### リレーからクライアントへ：イベントと通知の送信

リレーは5種類のメッセージを送信でき、これらもJSON配列でなければならず、以下のパターンに従います：

  * `["EVENT", <サブスクリプションID>, <上記で定義されたイベントJSON>]`：クライアントがリクエストしたイベントを送信するために使用されます。
  * `["OK", <イベントID>, <true|false>, <メッセージ>]`：`EVENT` メッセージの受け入れまたは拒否を示すために使用されます。
  * `["EOSE", <サブスクリプションID>]`：_保存されたイベントの終了_ とリアルタイムで新しく受信したイベントの開始を示すために使用されます。
  * `["CLOSED", <サブスクリプションID>, <メッセージ>]`：サーバー側でサブスクリプションが終了したことを示すために使用されます。
  * `["NOTICE", <メッセージ>]`：人間が読めるエラーメッセージやその他の情報をクライアントに送信するために使用されます。

この NIP では、`NOTICE` メッセージの送信や扱い方に関するルールは定義していません。

- `EVENT` メッセージは、クライアントが以前に開始したサブスクリプション（上記の `REQ` メッセージを使用）に関連するサブスクリプションIDでのみ送信されなければなりません（MUST）。
- `OK` メッセージは、クライアントから受信した `EVENT` メッセージに応答して送信されなければならず（MUST）、イベントがリレーに受け入れられた場合は3番目のパラメータを `true` に、そうでない場合は `false` に設定する必要があります。4番目のパラメータは常に存在しなければなりませんが（MUST）、3番目が `true` の場合は空の文字列でも構いません。それ以外の場合は、機械可読な単語のプレフィックスの後に `:` が続き、その後に人間が読めるメッセージが続く文字列でなければなりません。いくつかの例：
  * `["OK", "b1a649ebe8...", true, ""]`
  * `["OK", "b1a649ebe8...", true, "pow: difficulty 25>=24"]`
  * `["OK", "b1a649ebe8...", true, "duplicate: already have this event"]`
  * `["OK", "b1a649ebe8...", false, "blocked: you are banned from posting here"]`
  * `["OK", "b1a649ebe8...", false, "blocked: please register your pubkey at https://my-expensive-relay.example.com"]`
  * `["OK", "b1a649ebe8...", false, "rate-limited: slow down there chief"]`
  * `["OK", "b1a649ebe8...", false, "invalid: event creation date is too far off from the current time"]`
  * `["OK", "b1a649ebe8...", false, "pow: difficulty 26 is less than 30"]`
  * `["OK", "b1a649ebe8...", false, "error: could not connect to the database"]`
- `CLOSED` メッセージは、リレーが `REQ` の実行を拒否する場合に応答として送信されなければなりません（MUST）。また、クライアントが切断したり `CLOSE` を送信したりする前に、リレーが自身側でサブスクリプションを終了することを決定した場合にも送信できます。このメッセージは、機械可読なプレフィックスと人間が読めるメッセージを持つ `OK` メッセージと同じパターンを使用します。いくつかの例：
  * `["CLOSED", "sub1", "duplicate: sub1 already opened"]`
  * `["CLOSED", "sub1", "unsupported: filter contains unknown elements"]`
  * `["CLOSED", "sub1", "error: could not connect to the database"]`
  * `["CLOSED", "sub1", "error: shutting down idle subscription"]`
- `OK` と `CLOSED` の標準化された機械可読プレフィックスは：`duplicate`、`pow`、`blocked`、`rate-limited`、`invalid`、そしてそれらに当てはまらない場合の `error` です。