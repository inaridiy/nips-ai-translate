---
original: 23da4800a37b772e198b45632ab1e6a6678fe935448b3b37346996e8b23c7411
---

# NIP-46 - Nostr リモート署名

## 根拠

プライベートキーは、できるだけ少ないシステム（アプリ、オペレーティングシステム、デバイス）にのみ公開されるべきです。各システムが攻撃対象領域を増やすためです。

この NIP は、リモート署名者と Nostr クライアント間の双方向通信の方法を説明しています。リモート署名者は、例えば、Nostr イベントの署名専用のハードウェアデバイスであり、クライアントは通常の Nostr クライアントです。

## 用語

- **ローカルキーペア**: コンテンツの暗号化とリモート署名者との通信に使用されるローカルの公開鍵と秘密鍵のペア。通常、クライアントアプリケーションによって作成されます。
- **リモートユーザー公開鍵**: ユーザーが署名したい公開鍵。リモート署名者は、この公開鍵に対応する秘密鍵を管理しています。
- **リモート署名者公開鍵**: リモート署名者自体の公開鍵。これは `create_account` コマンドの両方で必要です。まだリモートユーザー公開鍵を持っていないためです。

この NIP で指定されているすべての公開鍵は16進数形式です。

## 接続の開始

クライアントとリモート署名者間の接続を開始するには、いくつかの異なるオプションがあります。

### リモート署名者によって開始される直接接続

これは、独自の nsecbunker や他のタイプのリモート署名者を持っていて、リモート署名をサポートするクライアントを通じて接続したい場合に最も一般的です。

リモート署名者は以下の形式の接続トークンを提供します：

```
bunker://<remote-user-pubkey>?relay=<wss://relay-to-connect-on>&relay=<wss://another-relay-to-connect-on>&secret=<optional-secret-value>
```

このトークンはユーザーによってクライアントに貼り付けられ、クライアントはその詳細を使用して指定されたリレーを介してリモート署名者に接続します。オプションのシークレットは、1回の成功した接続確立にのみ使用でき、リモート署名者は古いオプションのシークレットを使用した新しい接続確立の試みを無視すべきです。

### クライアントによって開始される直接接続

この場合、基本的に最初のケースの逆方向で、クライアントが接続トークンを提供し（またはトークンをQRコードにエンコードし）、署名者が指定されたリレーを介してクライアントへの接続を開始します。

```
nostrconnect://<local-keypair-pubkey>?relay=<wss://relay-to-connect-on>&metadata=<json metadata in the form: {"name":"...", "url": "...", "description": "..."}>
```

## フロー

1. クライアントがローカルキーペアを作成します。このキーペアは大部分が使い捨てであるため（つまり、ユーザーはこの公開鍵を見る必要がない）、ユーザーに伝える必要はありません。クライアントはこれをローカルに保存することを選択でき、ユーザーがログアウトしたときに削除する必要があります。
2. クライアントがリモートユーザー公開鍵を取得します（`bunker://` 接続文字列または NIP-05 ログインフローのいずれかを介して；以下に示します）
3. クライアントはローカルキーペアを使用して、リモートユーザー公開鍵に `p` タグを付けて暗号化することで、リモート署名者にリクエストを送信します。
4. リモート署名者は、ローカルキーペア公開鍵に `p` タグを付けて暗号化することで、クライアントに応答します。

### イベント署名の例フロー

- リモートユーザー公開鍵（例：署名者として）`fa984bd7dbb282f07e16e7ae87b26a2a7b9b90b7246a44771f0cf5ae58018f52`
- ローカル公開鍵は `eff37350d839ce3707332348af4549a96051bd695d3223af4aabce4993531d86`

#### 署名リクエスト

```json
{
    "kind": 24133,
    "pubkey": "eff37350d839ce3707332348af4549a96051bd695d3223af4aabce4993531d86",
    "content": nip04({
        "id": <random_string>,
        "method": "sign_event",
        "params": [json_stringified(<{
            content: "Hello, I'm signing remotely",
            kind: 1,
            tags: [],
            created_at: 1714078911
        }>)]
    }),
    "tags": [["p", "fa984bd7dbb282f07e16e7ae87b26a2a7b9b90b7246a44771f0cf5ae58018f52"]], // リモートユーザー公開鍵に p タグを付ける
}
```

#### レスポンスイベント

```json
{
    "kind": 24133,
    "pubkey": "fa984bd7dbb282f07e16e7ae87b26a2a7b9b90b7246a44771f0cf5ae58018f52",
    "content": nip04({
        "id": <random_string>,
        "result": json_stringified(<signed-event>)
    }),
    "tags": [["p", "eff37350d839ce3707332348af4549a96051bd695d3223af4aabce4993531d86"]], // ローカルキーペア公開鍵に p タグを付ける
}
```

#### 図

![signing-example](https://i.nostr.build/P3gW.png)

## リクエストイベント `kind: 24133`

```json
{
    "id": <id>,
    "kind": 24133,
    "pubkey": <local_keypair_pubkey>,
    "content": <nip04(<request>)>,
    "tags": [["p", <remote_user_pubkey>]], // 注意：`create_account` イベントでは、リモート署名者公開鍵に `p` タグを付ける必要があります。
    "created_at": <unix timestamp in seconds>
}
```

`content` フィールドは、JSON-RPC に似たメッセージで、[NIP-04](04.md) で暗号化され、以下の構造を持ちます：

```json
{
    "id": <random_string>,
    "method": <method_name>,
    "params": [array_of_strings]
}
```

- `id` はリクエスト ID としてのランダムな文字列です。このIDは応答ペイロードで同じものが送り返されます。
- `method` はメソッド/コマンドの名前です（詳細は以下）。
- `params` は文字列パラメータの位置配列です。

### メソッド/コマンド

以下はそれぞれ、クライアントがリモート署名者に送信するメソッドです。

| コマンド                 | パラメータ                                                                    | 結果                                                                    |
| ------------------------ | ---------------------------------------------------------------------------- | ----------------------------------------------------------------------- |
| `connect`                | `[<remote_user_pubkey>, <optional_secret>, <optional_requested_permissions>]` | "ack"                                                                   |
| `sign_event`             | `[<{kind, content, tags, created_at}>]`                                       | `json_stringified(<signed_event>)`                                      |
| `ping`                   | `[]`                                                                          | "pong"                                                                  |
| `get_relays`             | `[]`                                                                          | `json_stringified({<relay_url>: {read: <boolean>, write: <boolean>}})` |
| `get_public_key`         | `[]`                                                                          | `<hex-pubkey>`                                                          |
| `nip04_encrypt`          | `[<third_party_pubkey>, <plaintext_to_encrypt>]`                              | `<nip04_ciphertext>`                                                    |
| `nip04_decrypt`          | `[<third_party_pubkey>, <nip04_ciphertext_to_decrypt>]`                       | `<plaintext>`                                                           |
| `nip44_encrypt`          | `[<third_party_pubkey>, <plaintext_to_encrypt>]`                              | `<nip44_ciphertext>`                                                    |
| `nip44_decrypt`          | `[<third_party_pubkey>, <nip44_ciphertext_to_decrypt>]`                       | `<plaintext>`                                                           |

### リクエストされた権限

`connect` メソッドには、ユーザーの利便性のために `optional_requested_permissions` が提供される場合があります。権限は `method[:params]` のカンマ区切りリストです。例えば、`nip04_encrypt,sign_event:4` は `nip04_encrypt` を呼び出す権限と `kind:4` で `sign_event` を呼び出す権限を意味します。`sign_event` のオプションパラメータは kind 番号で、他のメソッドのパラメータは後で定義される予定です。

## レスポンスイベント `kind:24133`

```json
{
    "id": <id>,
    "kind": 24133,
    "pubkey": <remote_signer_pubkey>,
    "content": <nip04(<response>)>,
    "tags": [["p", <local_keypair_pubkey>]],
    "created_at": <unix timestamp in seconds>
}
```

`content` フィールドは、JSON-RPC に似たメッセージで、[NIP-04](04.md) で暗号化され、以下の構造を持ちます：

```json
{
    "id": <request_id>,
    "result": <results_string>,
    "error": <optional_error_string>
}
```

- `id` はこの応答が対応するリクエスト ID です。
- `results` は呼び出しの結果の文字列です（これは文字列または JSON 文字列化されたオブジェクトのいずれかです）
- `error` は、オプションで、エラーがある場合は文字列形式のエラーです。その存在はリクエストにエラーがあることを示します。

### 認証チャレンジ

認証チャレンジは、リモート署名者が他の手段でユーザーを認証する必要がある場合に送り返すことができるレスポンスです。これは現在、[Nsecbunker](https://github.com/kind-0/nsecbunkerd/) のような署名者が可能にする OAuth のようなフローで使用されています。レスポンスの `content` オブジェクトは以下の形式をとります：

```json
{
    "id": <request_id>,
    "result": "auth_url",
    "error": <URL_to_display_to_end_user>
}
```

クライアントは `error` フィールドの URL を（ポップアップまたは新しいタブで）表示し、リモート署名者からの別のレスポンスを購読/リッスンする必要があります（同じリクエスト ID を再利用）。このイベントは、ユーザーが他のウィンドウで認証した後に送信されます（またはユーザーが認証しない場合は送信されません）。また、auth_url に `redirect_uri` url パラメータを追加することも可能で、これはクライアントが認証チャレンジを表示するための新しいウィンドウやタブを開くことができない状況で役立ちます。

#### 認証チャレンジを含むイベント署名リクエストの例

![signing-example-with-auth-challenge](https://i.nostr.build/W3aj.png)

## リモート署名者コマンド

リモート署名者は、直接通信する際に追加のコマンドをサポートする場合があります。これらのコマンドは上記と同じフローに従いますが、唯一の違いは、クライアントがリクエストイベントを送信する際、`p` タグがリモート署名者自体の公開鍵であり、`content` ペイロードが同じリモート署名者公開鍵に暗号化されることです。

### メソッド/コマンド

以下はそれぞれ、クライアントがリモート署名者に送信するメソッドです。

| コマンド         | パラメータ                                                              | 結果                                   |
| ---------------- | ----------------------------------------------------------------------- | -------------------------------------- |
| `create_account` | `[<username>, <domain>, <optional_email>, <optional_requested_permissions>]` | `<newly_created_remote_user_pubkey>` |

## 付録

### NIP-05 ログインフロー

クライアントは、ユーザーがより馴染みのあるログインフローを提示することを選択し、`bunker://` 文字列の代わりに NIP-05 アドレスを入力できるようにすることがあります。

ユーザーが NIP-05 を入力すると、クライアントは：

- 提供された NIP-05 アドレスのドメインから `/.well-known/nostr.json` ファイルを照会して、ユーザーの公開鍵を取得します（これが**リモートユーザー公開鍵**です）
- 同じ `/.well-known/nostr.json` ファイルで、`nip46` キーを照会して、リモート署名者がリッスンするリレーを取得します。
- これで、クライアントはユーザーに代わってリモート署名者にコマンドを送信するのに十分な情報を持っています。


### OAuth のようなフロー

#### NIP-89 を介したリモート署名者の発見

この最後のケースでは、OAuth のようなサインインフローを容易にするために最もよく使用されます。クライアントはまず、NIP-89 アプリケーションハンドラーイベントを通じて自身を公開したリモート署名者を探します。

まず、クライアントは `k` タグに `24133` を持つ `kind: 31990` イベントを照会します。

これらは一般的にユーザーに表示され、ユーザーがどのリモート署名者を使用するかを選択し、使用したいリモートユーザー公開鍵（npub、公開鍵、または nip-05 値を介して）を提供すると、クライアントは接続を開始できます。この場合、実際に使用したいリモートキーを管理しているリモート署名者を選択するのはユーザーの責任です。リモートユーザー公開鍵が別のリモート署名者で管理されている場合、接続は失敗します。

さらに、クライアントが公開されたリモート署名者の公開鍵が、リモート署名者の公開されたドメインの `/.well-known/nostr.json` ファイルの `_` エントリの公開鍵と一致することを検証することが重要です。

新しいアカウントの作成をユーザーに許可するクライアントは、リモート署名者のドメインの名前空間で特定のユーザー名の利用可能性を、既存のユーザー名について `/.well-known/nostr.json` ファイルをチェックすることで検証することも検討すべきです。これにより、クライアントはリモート署名者に `create_account` イベントを送信してエラーを受け取る前に、UI でユーザーにフィードバックを表示できます。理想的には、リモート署名者も、クライアントが既存のユーザー名でアカウントを作成しようとした場合に理解しやすいエラーメッセージで応答するべきです。

#### Nsecbunker で新しいユーザーアカウントを作成する OAuth のようなフローの例

近日公開予定...

## 参考文献

- [NIP-04 - 暗号化](04.md)